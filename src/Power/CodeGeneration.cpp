#include "Power/CodeGeneration.h"
#include <sstream>
#include <algorithm>
#include <regex>
#include <cctype>

namespace GameEngine::Power::CodeGeneration {

CodeGenerator::CodeGenerator() {
    LoadEngineCodeTemplates();
    LoadExistingSymbols();
}

CodeGenerator::~CodeGenerator() = default;

GeneratedComponent CodeGenerator::GenerateEngineComponent(const ComponentRequest& request) {
    GeneratedComponent component;
    component.isValid = false;

    try {
        // Validate naming uniqueness
        if (!ValidateClassNameUniqueness(request.componentName)) {
            component.warnings.push_back("Class name conflict detected: " + request.componentName);
            std::string alternative = GenerateAlternativeName(request.componentName, "class");
            component.warnings.push_back("Suggested alternative: " + alternative);
        }

        // Generate namespace
        std::string namespaceStr = GenerateNamespace(request.targetModule, request.componentName);
        if (!ValidateNamespaceUniqueness(namespaceStr)) {
            component.warnings.push_back("Namespace conflict detected: " + namespaceStr);
        }

        // Generate files
        component.headerFile = GenerateHeaderFile(request);
        component.sourceFile = GenerateSourceFile(request);
        component.testFile = GenerateTestFile(request);
        component.cmakeIntegration = GenerateCMakeIntegration(request);

        // Copy dependencies
        component.dependencies = request.dependencies;

        // Validate naming conventions
        if (!ValidateNamingConventions(component)) {
            component.warnings.push_back("Some naming conventions may not be followed");
        }

        // Check for symbol conflicts
        auto conflicts = CheckSymbolConflicts(component);
        if (!conflicts.empty()) {
            component.warnings.insert(component.warnings.end(), conflicts.begin(), conflicts.end());
        }

        component.isValid = true;

    } catch (const std::exception& e) {
        component.warnings.push_back("Exception during code generation: " + std::string(e.what()));
        component.isValid = false;
    }

    return component;
}

GeneratedShaderPair CodeGenerator::GenerateShaderPair(const ShaderRequest& request) {
    GeneratedShaderPair shaderPair;
    shaderPair.isValid = false;

    try {
        std::stringstream vertexShader;
        std::stringstream fragmentShader;

        // Generate vertex shader
        vertexShader << "#version 460 core\n\n";
        vertexShader << "// " << request.shaderName << " Vertex Shader\n";
        vertexShader << "// Generated by Game Engine Kiro Code Generator\n\n";

        // Add attributes
        vertexShader << "// Vertex Attributes\n";
        int location = 0;
        for (const auto& attr : request.attributes) {
            vertexShader << "layout(location = " << location++ << ") in vec3 " << attr << ";\n";
            shaderPair.attributeList.push_back(attr);
        }
        vertexShader << "\n";

        // Add uniforms
        vertexShader << "// Uniforms\n";
        for (const auto& uniform : request.uniforms) {
            vertexShader << "uniform mat4 " << uniform << ";\n";
            shaderPair.uniformList.push_back(uniform);
        }
        vertexShader << "\n";

        // Add skeletal animation support if requested
        if (request.includeSkeletalAnimation) {
            vertexShader << "// Skeletal Animation\n";
            vertexShader << "const int MAX_BONES = 256;\n";
            vertexShader << "uniform mat4 u_boneMatrices[MAX_BONES];\n";
            vertexShader << "layout(location = " << location++ << ") in ivec4 a_boneIDs;\n";
            vertexShader << "layout(location = " << location++ << ") in vec4 a_boneWeights;\n\n";
        }

        vertexShader << "void main() {\n";
        vertexShader << "    // Vertex shader main logic\n";
        vertexShader << "    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n";
        vertexShader << "}\n";

        // Generate fragment shader
        fragmentShader << "#version 460 core\n\n";
        fragmentShader << "// " << request.shaderName << " Fragment Shader\n";
        fragmentShader << "// Generated by Game Engine Kiro Code Generator\n\n";

        fragmentShader << "// Output\n";
        fragmentShader << "out vec4 FragColor;\n\n";

        // Add PBR lighting if requested
        if (request.includePBRLighting) {
            fragmentShader << "// PBR Lighting\n";
            fragmentShader << "uniform vec3 u_lightPosition;\n";
            fragmentShader << "uniform vec3 u_lightColor;\n";
            fragmentShader << "uniform float u_metallic;\n";
            fragmentShader << "uniform float u_roughness;\n\n";
        }

        fragmentShader << "void main() {\n";
        fragmentShader << "    // Fragment shader main logic\n";
        fragmentShader << "    FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n";
        fragmentShader << "}\n";

        shaderPair.vertexShader = vertexShader.str();
        shaderPair.fragmentShader = fragmentShader.str();
        shaderPair.isValid = true;

    } catch (const std::exception& e) {
        shaderPair.isValid = false;
    }

    return shaderPair;
}

std::string CodeGenerator::GenerateTestSuite(const std::string& componentName, 
                                             const std::vector<std::string>& properties) {
    std::stringstream ss;

    ss << "#include \"TestUtils.h\"\n";
    ss << "#include \"" << componentName << ".h\"\n\n";
    ss << "using namespace GameEngine;\n";
    ss << "using namespace GameEngine::Testing;\n\n";

    // Generate test functions for each property
    for (size_t i = 0; i < properties.size(); ++i) {
        ss << "/**\n";
        ss << " * Test " << properties[i] << "\n";
        ss << " * Requirements: TBD\n";
        ss << " */\n";
        ss << "bool Test" << ApplyNamingConventions(properties[i], "class") << "() {\n";
        ss << "    TestOutput::PrintTestStart(\"" << properties[i] << "\");\n\n";
        ss << "    // Test implementation\n";
        ss << "    EXPECT_TRUE(true);\n\n";
        ss << "    TestOutput::PrintTestPass(\"" << properties[i] << "\");\n";
        ss << "    return true;\n";
        ss << "}\n\n";
    }

    // Generate main function
    ss << "int main() {\n";
    ss << "    TestOutput::PrintHeader(\"" << componentName << "\");\n\n";
    ss << "    bool allPassed = true;\n\n";
    ss << "    try {\n";
    ss << "        TestSuite suite(\"" << componentName << " Tests\");\n\n";

    for (const auto& prop : properties) {
        ss << "        allPassed &= suite.RunTest(\"" << prop << "\", Test" 
           << ApplyNamingConventions(prop, "class") << ");\n";
    }

    ss << "\n        suite.PrintSummary();\n\n";
    ss << "        TestOutput::PrintFooter(allPassed);\n";
    ss << "        return allPassed ? 0 : 1;\n\n";
    ss << "    } catch (const std::exception& e) {\n";
    ss << "        TestOutput::PrintError(\"TEST EXCEPTION: \" + std::string(e.what()));\n";
    ss << "        return 1;\n";
    ss << "    } catch (...) {\n";
    ss << "        TestOutput::PrintError(\"UNKNOWN TEST ERROR!\");\n";
    ss << "        return 1;\n";
    ss << "    }\n";
    ss << "}\n";

    return ss.str();
}

void CodeGenerator::LoadEngineCodeTemplates() {
    // Graphics templates
    m_classTemplates["graphics_renderer"] = R"(
class {{CLASS_NAME}} {
public:
    {{CLASS_NAME}}();
    ~{{CLASS_NAME}}();

    bool Initialize();
    void Render();
    void Shutdown();

private:
    // OpenGL state
    bool m_isInitialized;
};
)";

    m_classTemplates["graphics_shader"] = R"(
class {{CLASS_NAME}} {
public:
    {{CLASS_NAME}}();
    ~{{CLASS_NAME}}();

    bool LoadFromFile(const std::string& vertexPath, const std::string& fragmentPath);
    void Use();
    void SetUniform(const std::string& name, const glm::mat4& value);

private:
    GLuint m_programID;
    bool m_isCompiled;
};
)";

    // Physics templates
    m_classTemplates["physics_bullet"] = R"(
class {{CLASS_NAME}} {
public:
    {{CLASS_NAME}}();
    ~{{CLASS_NAME}}();

    bool Initialize();
    void Update(float deltaTime);
    void Shutdown();

private:
    btDiscreteDynamicsWorld* m_dynamicsWorld;
    btBroadphaseInterface* m_broadphase;
    btCollisionDispatcher* m_dispatcher;
    btConstraintSolver* m_solver;
    btDefaultCollisionConfiguration* m_collisionConfiguration;
};
)";

    // Audio templates
    m_classTemplates["audio_openal"] = R"(
class {{CLASS_NAME}} {
public:
    {{CLASS_NAME}}();
    ~{{CLASS_NAME}}();

    bool Initialize();
    void PlaySound(const std::string& soundPath);
    void SetListenerPosition(const glm::vec3& position);
    void Shutdown();

private:
    ALCdevice* m_device;
    ALCcontext* m_context;
    std::vector<ALuint> m_sources;
    std::vector<ALuint> m_buffers;
};
)";

    // Animation templates
    m_classTemplates["animation_controller"] = R"(
class {{CLASS_NAME}} {
public:
    {{CLASS_NAME}}();
    ~{{CLASS_NAME}}();

    bool Initialize();
    void Update(float deltaTime);
    void PlayAnimation(const std::string& animationName);
    void SetBlendWeight(float weight);

private:
    std::map<std::string, AnimationClip> m_animations;
    float m_currentTime;
    float m_blendWeight;
};
)";

    // Resource templates
    m_classTemplates["resource_loader"] = R"(
class {{CLASS_NAME}} {
public:
    {{CLASS_NAME}}();
    ~{{CLASS_NAME}}();

    bool LoadResource(const std::string& path);
    void UnloadResource(const std::string& path);
    bool IsLoaded(const std::string& path) const;

private:
    std::map<std::string, std::shared_ptr<Resource>> m_resources;
    std::mutex m_mutex;
};
)";
}

std::string CodeGenerator::GetGraphicsTemplate(const std::string& componentType) {
    std::string key = "graphics_" + componentType;
    std::transform(key.begin(), key.end(), key.begin(), ::tolower);
    
    auto it = m_classTemplates.find(key);
    if (it != m_classTemplates.end()) {
        return it->second;
    }
    return m_classTemplates["graphics_renderer"]; // Default
}

std::string CodeGenerator::GetPhysicsTemplate(const std::string& backendType) {
    std::string key = "physics_" + backendType;
    std::transform(key.begin(), key.end(), key.begin(), ::tolower);
    
    auto it = m_classTemplates.find(key);
    if (it != m_classTemplates.end()) {
        return it->second;
    }
    return m_classTemplates["physics_bullet"]; // Default
}

std::string CodeGenerator::GetAudioTemplate(const std::string& componentType) {
    return m_classTemplates["audio_openal"];
}

std::string CodeGenerator::GetAnimationTemplate(const std::string& componentType) {
    return m_classTemplates["animation_controller"];
}

std::string CodeGenerator::GetResourceTemplate(const std::string& componentType) {
    return m_classTemplates["resource_loader"];
}

bool CodeGenerator::ValidateNamespaceUniqueness(const std::string& namespaceName) {
    return m_existingNamespaces.find(namespaceName) == m_existingNamespaces.end();
}

bool CodeGenerator::ValidateClassNameUniqueness(const std::string& className) {
    return m_existingClasses.find(className) == m_existingClasses.end();
}

bool CodeGenerator::ValidateNamingConventions(const GeneratedComponent& component) {
    // Basic validation - check if files are not empty
    return !component.headerFile.empty() && !component.sourceFile.empty();
}

std::vector<std::string> CodeGenerator::CheckSymbolConflicts(const GeneratedComponent& component) {
    std::vector<std::string> conflicts;
    // Placeholder for symbol conflict detection
    return conflicts;
}

std::string CodeGenerator::GenerateAlternativeName(const std::string& baseName, const std::string& symbolType) {
    // Simple strategy: append module name or number
    return baseName + "Extended";
}

std::string CodeGenerator::GenerateBulletPhysicsIntegration(const std::string& componentName) {
    std::stringstream ss;
    ss << "// Bullet Physics Integration for " << componentName << "\n";
    ss << "#include <btBulletDynamicsCommon.h>\n\n";
    ss << "// Initialize Bullet Physics\n";
    ss << "btDefaultCollisionConfiguration* collisionConfiguration = new btDefaultCollisionConfiguration();\n";
    ss << "btCollisionDispatcher* dispatcher = new btCollisionDispatcher(collisionConfiguration);\n";
    return ss.str();
}

std::string CodeGenerator::GeneratePhysXIntegration(const std::string& componentName) {
    std::stringstream ss;
    ss << "// PhysX Integration for " << componentName << "\n";
    ss << "// PhysX integration code will be added here\n";
    return ss.str();
}

std::string CodeGenerator::GenerateOpenALIntegration(const std::string& componentName) {
    std::stringstream ss;
    ss << "// OpenAL Integration for " << componentName << "\n";
    ss << "#include <AL/al.h>\n";
    ss << "#include <AL/alc.h>\n\n";
    ss << "// Initialize OpenAL\n";
    ss << "ALCdevice* device = alcOpenDevice(nullptr);\n";
    ss << "ALCcontext* context = alcCreateContext(device, nullptr);\n";
    return ss.str();
}

std::string CodeGenerator::GenerateOpenGLIntegration(const std::string& componentName) {
    std::stringstream ss;
    ss << "// OpenGL Integration for " << componentName << "\n";
    ss << "#include <glad/glad.h>\n\n";
    ss << "// Initialize OpenGL resources\n";
    ss << "GLuint vao, vbo;\n";
    ss << "glGenVertexArrays(1, &vao);\n";
    ss << "glGenBuffers(1, &vbo);\n";
    return ss.str();
}

std::string CodeGenerator::GenerateSkeletalAnimationIntegration(const std::string& componentName) {
    std::stringstream ss;
    ss << "// Skeletal Animation Integration for " << componentName << "\n";
    ss << "#include \"Animation/AnimationController.h\"\n";
    ss << "#include \"Animation/AnimationSkeleton.h\"\n\n";
    ss << "// Initialize skeletal animation\n";
    ss << "AnimationController controller;\n";
    ss << "controller.Initialize();\n";
    return ss.str();
}

std::string CodeGenerator::ApplyNamingConventions(const std::string& name, const std::string& type) {
    std::string result = name;
    
    if (type == "class" || type == "namespace") {
        // PascalCase
        bool capitalizeNext = true;
        for (char& c : result) {
            if (c == '_' || c == ' ') {
                capitalizeNext = true;
            } else if (capitalizeNext) {
                c = static_cast<char>(std::toupper(c));
                capitalizeNext = false;
            } else {
                c = static_cast<char>(std::tolower(c));
            }
        }
        result.erase(std::remove(result.begin(), result.end(), '_'), result.end());
        result.erase(std::remove(result.begin(), result.end(), ' '), result.end());
    } else if (type == "variable" || type == "method") {
        // camelCase with m_ prefix for members
        result = ApplyNamingConventions(name, "class");
        if (!result.empty()) {
            result[0] = static_cast<char>(std::tolower(result[0]));
        }
    } else if (type == "constant" || type == "macro") {
        // UPPER_SNAKE_CASE
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
        std::replace(result.begin(), result.end(), ' ', '_');
    }
    
    return result;
}

std::string CodeGenerator::GenerateNamespace(const std::string& module, const std::string& component) {
    return "GameEngine::" + module + "::" + ApplyNamingConventions(component, "namespace");
}

std::string CodeGenerator::GenerateIncludes(const std::vector<std::string>& dependencies) {
    std::stringstream ss;
    for (const auto& dep : dependencies) {
        ss << "#include \"" << dep << ".h\"\n";
    }
    return ss.str();
}

std::string CodeGenerator::GenerateHeaderFile(const ComponentRequest& request) {
    std::stringstream ss;
    auto placeholders = GenerateDefaultPlaceholders(request);
    
    // Header guard
    std::string guardName = "GAMEENGINE_" + request.targetModule + "_" + request.componentName + "_H";
    std::transform(guardName.begin(), guardName.end(), guardName.begin(), ::toupper);
    
    ss << "#pragma once\n\n";
    ss << "#ifndef " << guardName << "\n";
    ss << "#define " << guardName << "\n\n";
    
    // Includes
    ss << GenerateIncludes(request.dependencies);
    ss << "\n";
    
    // Namespace
    ss << "namespace " << GenerateNamespace(request.targetModule, request.componentName) << " {\n\n";
    
    // Get appropriate template
    std::string templateContent;
    if (request.targetModule == "Graphics") {
        templateContent = GetGraphicsTemplate(request.componentType);
    } else if (request.targetModule == "Physics") {
        templateContent = GetPhysicsTemplate("bullet");
    } else if (request.targetModule == "Audio") {
        templateContent = GetAudioTemplate(request.componentType);
    } else if (request.targetModule == "Animation") {
        templateContent = GetAnimationTemplate(request.componentType);
    } else if (request.targetModule == "Resource") {
        templateContent = GetResourceTemplate(request.componentType);
    }
    
    // Process template
    std::string processedTemplate = ProcessTemplatePlaceholders(templateContent, placeholders);
    ss << processedTemplate;
    
    ss << "\n} // namespace " << GenerateNamespace(request.targetModule, request.componentName) << "\n\n";
    ss << "#endif // " << guardName << "\n";
    
    return ss.str();
}

std::string CodeGenerator::GenerateSourceFile(const ComponentRequest& request) {
    std::stringstream ss;
    
    ss << "#include \"" << request.targetModule << "/" << request.componentName << ".h\"\n\n";
    ss << "namespace " << GenerateNamespace(request.targetModule, request.componentName) << " {\n\n";
    
    ss << "// Implementation for " << request.componentName << "\n\n";
    
    ss << "} // namespace " << GenerateNamespace(request.targetModule, request.componentName) << "\n";
    
    return ss.str();
}

std::string CodeGenerator::GenerateTestFile(const ComponentRequest& request) {
    std::vector<std::string> properties = {"initialization", "basic functionality", "error handling"};
    return GenerateTestSuite(request.componentName, properties);
}

std::string CodeGenerator::GenerateCMakeIntegration(const ComponentRequest& request) {
    std::stringstream ss;
    
    ss << "# CMake integration for " << request.componentName << "\n";
    ss << "target_sources(GameEngineKiro PRIVATE\n";
    ss << "    src/" << request.targetModule << "/" << request.componentName << ".cpp\n";
    ss << ")\n\n";
    ss << "target_include_directories(GameEngineKiro PUBLIC\n";
    ss << "    include/" << request.targetModule << "\n";
    ss << ")\n";
    
    return ss.str();
}

void CodeGenerator::LoadExistingSymbols() {
    // Placeholder - would scan project files in real implementation
    m_existingNamespaces.insert("GameEngine");
    m_existingNamespaces.insert("GameEngine::Graphics");
    m_existingNamespaces.insert("GameEngine::Physics");
    m_existingNamespaces.insert("GameEngine::Audio");
}

std::string CodeGenerator::ProcessTemplatePlaceholders(const std::string& templateContent,
                                                       const std::map<std::string, std::string>& placeholders) {
    std::string result = templateContent;
    
    for (const auto& placeholder : placeholders) {
        std::string token = "{{" + placeholder.first + "}}";
        size_t pos = 0;
        while ((pos = result.find(token, pos)) != std::string::npos) {
            result.replace(pos, token.length(), placeholder.second);
            pos += placeholder.second.length();
        }
    }
    
    return result;
}

std::map<std::string, std::string> CodeGenerator::GenerateDefaultPlaceholders(const ComponentRequest& request) {
    std::map<std::string, std::string> placeholders;
    
    placeholders["CLASS_NAME"] = ApplyNamingConventions(request.componentName, "class");
    placeholders["MODULE_NAME"] = request.targetModule;
    placeholders["COMPONENT_TYPE"] = request.componentType;
    placeholders["NAMESPACE"] = GenerateNamespace(request.targetModule, request.componentName);
    
    return placeholders;
}

bool CodeGenerator::ValidateTemplate(const std::string& templateContent) {
    // Check for balanced placeholders
    size_t openCount = 0;
    size_t closeCount = 0;
    
    size_t pos = 0;
    while ((pos = templateContent.find("{{", pos)) != std::string::npos) {
        openCount++;
        pos += 2;
    }
    
    pos = 0;
    while ((pos = templateContent.find("}}", pos)) != std::string::npos) {
        closeCount++;
        pos += 2;
    }
    
    return openCount == closeCount;
}

} // namespace GameEngine::Power::CodeGeneration
